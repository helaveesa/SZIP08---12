Информатика и Ассемблер

ВВЕДЕНИЕ.

1. История развития ЭВМ.

ЭВМ - вычислительная машина, в которой основные функциональные элементы (логические, арифметические, запоминающие и др.) выполнены на электронных приборах. ЭВМ разделяются на АВМ и ЦВМ. Первые ЭВМ - 40 гг. XX в. В развитии ЭВМ обычно выделяют 4 поколения: 1 поколение - 40-е - начало 50-х - на электронных лампах; 2 поколение - середина 50-х - начало 60-х - на дискретных полупроводниковых приборах; 3 поколение - с середины 60-х - на больших интегральных схемах; 5 поколение - обычно - современные компьютеры.

Первый микропроцессор, реализованный в виде одной интегральной схемы появился в 1971 году. Разработчик - фирма Intel. 4-разрядный. 1974г. - процессор 8080 8-разрядный и с памятью до 64Кб. 1976г. - первая персональная ЭВМ разработана фирмой Apple. 1978г. 8086 - 16 разрядный процессор с памятью до 1 Мб, в 1981г. - на базе которого фирма IBM создала ПК IBM PC. 1983г. - усовершенствованная его модель IBM PC XT. 1983 г. Intel выпускает 80186, не получивший распространения, т.к. в том же году выпущен 80286, на основе которого IBM в 1984 г. создает IBM PC AT. 80286 предусматривает средства реализации многозадачного режима работы ЭВМ. Однако ввиду малой мощности процессора он использовался как более быстрый 8086. В 1987 г. создан i386 32 разрядный с 4 Гб адресным пространством. Может работать в двух режимах - реальном (Real Mode, точнее - виртуальный V86) и защищенном (Protected Mode). Ввиду значительной стоимости появился упрощенный вариант 80386SX - с размером регистров 32 разряда, а шины данных и шины адреса - 16 разрядов. Тактовая частота базового процессора 80386 - 16 МГц, а затем выпущены 80386 с частотой 25, 33 и 40 МГц. 1990г - процессор i486. Март 1993г. - 64 разрядный процессор, получивший имя Pentium, тактовая частота первых процессоров 60 и 66 МГц, - Р5, более поздние модификации - Р54 75-200 Мгц, Р55 - с ММХ технологией - 57 новых инструкций. Частота 166-233 МГц. 1997г. - Pentium II и в 1999 году - Pentium III. Все перечисленные процессоры соблюдают преемственностью: программа, написанная для младшей модели может быть выполнена на любой более старшей модели, таким образом программа, составленная для 8086 будет выполняться на всех остальных процессорах серии, что позволяет называть их семейством 80х86.

2. Понятия.

Процессор (CPU - Central Processing Unit) с точки зрения программирования - это устройство, выполняющее математические действия над числами, находящимися в основной памяти компьютера и специальных внутренних ячейках - регистрах. Кроме того, CPU выполняет ряд дополнительных действий, которые будут рассмотрены далее.

Команда процессора - указание процессору выполнить определенное действие. Каждая команда имеет свой номер (численное значение), который хранится в определенной ячейке памяти.

Программа - это последовательность команд, выполнение которой приводит к требуемому результату. Виды программ:

в машинных кодах (машинноориентированный язык) - последовательность команд процессора;

низкоуровневые (ассемблер) - содержат мнемокоды (символьные обозначения) команд процессора;

высокоуровневые – содержат последовательность условных выражений (команд) и обозначений, имеющую определенный математический смысл и составленную в соответствии с определенными правилами.

Все программы сводятся к машинному коду при помощи автоматического транслятора.

Автоматический транслятор (translator - переводчик)– это программа, которая проверяет текст исходной программы (на языке высокого уровня или ассемблере) и создает из файла с этим текстом другой файл, содержащий машинный код и выполняющий аналогичные действия.

Язык программирования (система программирования) - совокупность средств, позволяющая составлять (писать) программы.

Назначение языков программирования - облегчить работу по составлению программ и создать наглядность для их просмотра и редактирования.

Средства, входящие в состав языка программирования:

прикладные - текстовый редактор для набора и коррекции программ;

собственные компоненты языка - условные слова, выражения, знаки.

3.Классификация языков программирования

по уровням

языки низкого уровня (ассемблер - мнемокоды команд процессора с возможностью использования обозначаемых символами переменных, вызова процедур и т.д.);

языки высокого уровня [я.в.у.](Фортран, Алгол, ПЛ-1, Бейсик, Паскаль, Си, Ада, Дельфи);

По назначению:

для создания прикладных программ;

для создания специальных программ управления автоматическими системами а также проектирования данных систем;

4. Исторические фазы развития языков программирования

Машинные коды, двоичная система исчисления Þ восьмеричная, т.к. одна команда занимала 1байт, затем hex. Команда сложения для БЭСМ-2 выглядела 01002200230024

Ассемблер. Использование машинных кодов неудобно, создание автоматического компилятора представило новые возможности. Назначение - написание операционных систем, создание низкоуровневых процедур благодаря непосредственной связи с аппаратной частью РС.

Фортран - язык высокого уровня, один из первых. Создан в 1956г. Бланк Фортрана. Строка - присвоение значения переменным, вызов процедуры и т.п. Версии: Ф-IV, Ф-66 (1966), Ф-77 (1977), и последний вариант - Ф - 90 Назначение - математические и инженерные расчеты (а не создание функциональных программ)

Basic - Все строки имеют соответствующие номера. Назначение: получает широчайшее распространение в персональных компьютерах типа БК.

Паскаль, появившийся в 1969 и практически следом за ним Си(1972) завоевали признание программистов и пользователей компьютеров типа ППЭВМ.

Паскаль, названный в честь Блеза Паскаля, французского математика, предложен Николасом Виртом, разработан им на основе Алгола-60 и Алгола-W

Си разработан: Ритчи. Для работы под UNIX.

Языки обладают значительным удобством и представляют программисту широкие возможности создания всего спектра программ - от вычислительных до системных программ при помощи вставок машинного кода или фрагментов ассемблерных команд. 

ГЛАВА 1. ОСНОВНЫЕ ОСОБЕННОСТИ АРХИТЕКТУРЫ ПК.

1.1. Краткие сведения об ОП.

ОП ПК делится на ячейки размером 8 разрядов. Такие ячейки называются байтами (byte). Разряды в нем нумеруются справа налево от 0 до 7

байт

	

	

	

	

	

	

	

7
	

6
	

5
	

4
	

3
	

2
	

1
	

0

 

 

В каждом разряде может быть записана величина 1 или 0, которую называют битом (bit). Значение ,бита определяется 2n по принципам двоичной системы. Правые разряды байта - младшие, левые - старшие. Байт - наименьшая адресуемая ячейка памяти. Кроме того имеются ячейки другого размера. Слово (word) - два соседних байта. Размер - 16 разрядов. Нумеруются справа налево от 0 до 15. Адрес байта - адрес его первого байта (с меньшим адресом)

слово с адресом А

А
	

А+1
	

	

15
	

8
	

7
	

0

 

 

Двойное слово (double word) - это четыре соседних байта или 2 слова. Размер - 32 разряда. Нумеруются справа налево от 0 до 31. Адрес - там же.

Двойное слово с адресом А

А
	

А+1
	

А+2
	

А+3
	

	

	

	

31
	

24
	

23
	

16
	

15
	

8
	

7
	

0

 

 

1.2. Регистры

1.2.1. Понятие регистра

Для кратковременного хранения и обработки данных в МП предусмотрены специальные ячейки памяти, конструктивно расположенные внутри МП и доступные из программ. Такие ячейки называются регистрами. Доступ к регистрам осуществляется гораздо быстрее, чем к ОП. В 8086 процессоре все регистры имеют разряд слова (16) и каждый имеет имя. В 386 -32. По назначению и способу использования регистры можно разделить на следующие группы.

РОН (AX, BX, CX, DX, SI, DI, BP, SP), в 386 - Е - EAX;

сегментные регистры (CS, DS, SS, ES) в 386 - FS, GS;

регистр флагов.

регистр IP.

1.2.2. Регистры общего назначения

К ним относятся: AX: AH/AL, BX: BH/BL, CX: CH/CL, DX: DH/DL, SI, DI, BP, SP.

AX - (accumulator) аккумулятор, BX - (base) база, CX - (counter) счетчик, DX (data) данные, extended. SI - (source index) индекс источника, DI (destination index), индекс приемника BP (base pointer) указатель базы, SP (stack pointer). РОНы можно использовать в любых арифметических, логических операциях. Однако каждый РОН имеет определенную спецификацию: некоторые команды требуют, чтобы их операнд или операнды находились в определенных регистрах. Делимое - ax,dx.

1.2.3. Сегментные регистры

Сегментные регистры CS, DS, SS и ES (Code, data, stack, extra segments) не могут быть операндами никаких команд, кроме команд пересылки и стековых команд. Эти регистры используются только для сегментирования адресов

1.2.4. Регистр флагов.

В ПК имеется особый регистр флагов. Флаг - это бит, принимающий значение 1 ("флаг установлен"), если выполнено некоторое условие, и значение 0 ("флаг сброшен") в противном случае. В ПК используется 9 флагов, каждому из них присвоено определенное имя (ZF, CF и т.д.). Все они собраны в регистре флагов (каждый флаг - это один из разрядов регистра, часть его разрядов не используется):

Flags

x
	

x
	

x
	

x
	

x
	

OF
	

DF
	

IF
	

TF
	

SF
	

ZF
	

AF
	

x
	

PF
	

x
	

CF

15
	

14
	

13
	

12
	

11
	

10
	

9
	

8
	

7
	

6
	

5
	

4
	

3
	

2
	

1
	

0

 

Некоторые флаги принято называть флагами условий; они автоматически меняются при выполнении команд и фиксируют те или иные свойства их результата (например, равен ли он нулю). Другие флаги называются флагами состояний; они меняются из программы и оказывают влияние на дальнейшее поведение процессора (например, блокируют прерывания).

Флаги условий:

CF (carry flag) - флаг переноса. Принимает значение 1, если при

сложении целых чисел появилась единица переноса, не "влезающая" в разрядную сетку, или если при вычитании чисел без знака первое из них было меньше второго. В командах сдвига в CF заносится бит, вышедший за

разрядную сетку. CF фиксирует также особенности команды умножения.

OF (overflow flag) - флаг переполнения. Устанавливается в 1, если

при сложении или вычитании целых чисел со знаком получился результат,

по модулю превосходящий допустимую величину (произошло переполнение

мантиссы и она "залезла" в знаковый разряд).

ZF (zero flag) - флаг нуля. Устанавливается в 1, если результат

команды оказался равным 0.

SF (sign flag) - флаг знака. Устанавливается в 1, если в операции

над знаковыми числами получился отрицательный результат.

PF (parity flag) - флаг четности. Равен 1, если результат очеред-

ной команды содержит четное количество двоичных единиц. Учитывается

обычно только при операциях ввода-вывода.

AF (auxiliary carry flag) - флаг дополнительного переноса. Фикси-

рует особенности выполнения операций над двоично-десятичными числами.

Флаги состояний:

DF (direction flag) - флаг направления. Устанавливает направление

просмотра строк в строковых командах: при DF=0 строки просматриваются

"вперед" (от начала к концу), при DF=1 - в обратном направлении.

IF (interrupt flag) - флаг прерываний. При IF=0 процессор переста-

ет реагировать на поступающие к нему прерывания, при IF=1 блокировка

прерываний снимается.

TF (trap flag) - флаг трассировки. При TF=1 после выполнения каж-

дой команды процессор делает прерывание (с номером 1), чем можно вос-

пользоваться при отладке программы для ее трассировки.

1.2.5. Регистр IP.

Счетчик команд IP всегда содержит адрес (смещение от начала программы) той команды, которая должна быть выполнена следующей (начало программы хранится в регистре CS). Содержимое регистра IP можно изменить только командами перехода.

1.3. Оперативная память ПК.

1.3.1. Представление чисел в памяти ПК.

Система команд процессора ПК поддерживает работу только с числами, размером в байт, слово , двойное слово, то есть с целыми числами, а если число имеет иное количество байтов или имеет иной формат, то все операции над ним надо реализовывать самому программисту. Для начала рассмотрим представление в памяти ПК целых чисел. Имеется различие между целыми числами без знака (неотрицательными) и со знаком. В одинаковых ячейках памяти можно представить больший диапазон беззнаковых чисел, чем чисел со знаком. В байте беззнаковых - 0-255, а неотрицательные числа со знаком 0-127, поэтому, если известно, что число не - то его лучше представить как беззнаковую величину.

Беззнаковые числа. Целые числа без знака записываются в следующие ячейки в следующих диапазонах: байт 0-255, слово - 0-65535, dw - 0-4 2994 967 295. Особенность представления чисел в памяти ПК: в «перевернутом» виде, то есть старшие разряды размещаются во втором байте , а младшие - в первом. Например число 56h если занимает слово то 0056 а в памяти 56/00(А/А+1). Первые процессоры 8разрядные. Но 1234h в памяти 34/12(А/А+1) в регистре - в нормальном виде 12/34(AH/AL). Это контролируют команды пересылки. Аналогично - для dw - число 12345678h хранится в памяти 78/56/34/12(А/А+1/А+2/А+3/).

Числа со знаком. Диапазоны: байт:-127¸+127, слово: -32768¸32767, двойное- -2 147 483 648 ¸2 147 483 647. Записываются в дополнительном коде доп(х)={х при х>=0 и 2k - ½x½ при х<0, для байта доп(0)=0=00000000, доп(1)=1=00000001, доп(2)=2=00000010, доп(127)=127=01111111, доп(-1)=256-1=11111111, доп(-2)=256-2=11111110 доп(-128)=256-1=10000000. Левый бит -роль знакового. Существует двоично-десятичная запись чисел BCD - binary coded decimal. Символы - каждый свой номер. ASCII (American Standard Code for Information Interchange).

1.3.2 Особенности выполнения арифметических опреаций

В ПК имеются команды сложения и вычитания целых чисел размером в слово и байт. Специальных команд для сложения и вычитания двойных слов нет, эти операции реализуются через команды сложения и вычитания слов.

Сложение и вычитание беззнаковаых чисел производится по модулю 28 для байтов и 216 для слов. Это означает, что если в результате сложения появилась единица переноса, не вмещающаяся в разрядную сетку, то она отбрасывается. Например, при сложении байтов 128 и 130 получается число 258 = 100000010b, поэтому левая двоичная единица отбрасывается и остается число 2 = 10b, которое и объявляется результатом сложения. Ошибка здесь не фиксируется, но в флаг переноса CF записывается 1 (если переноса не было, в CF заносится 0). "Поймать" такое искажение суммы можно только последующим анализом флага CF.

Искажение результата происходит и при вычитание из меньшего числа большего. И здесь не фиксируется ошибка, однако первому числу дается "заем единицы" (в случае байтов это число увеличивается на 256, для слов - на 216), после чего и производится вычитание. Например, вычитание байтов 2 и 3 сводится к вычитанию чисел 256+2=258 и 3, в результате чего получается неправильная разность 255 (а не -1). Для того чтобы можно было обнаружить такую ситуацию, в флаг переноса CF заносится 1 (если заема не было, в CF записывается 0).

Сложение и вычитание знаковых целых чисел производится по тем же алгоритмам, что и для беззнаковых чисел (в этом одно из достоинств дополнительного кода): знаковые числа рассматриваются как соответствующие беззнаковые числа, производится операция над этими беззнаковыми числами и полученный результат интерпретируется как знаковое число. Например, сложение байтовых чисел 1 и -2 происходит так: берутся их дополнительные коды 1 и (256-2)=254, вычисляется сумма этих величин 1+254=255 и она трактуется как знаковое число -1 (255=256-1). Если при таком сложении возникла единица переноса, то она, как обычно, отбрасывается, а флаг CF получает значение 1. Однако в данном случае это отсечение не представляет интерес - результат операции будет правильным, например: 3+(-2) => 3+254(mod 256) = 257(mod 256) = 1. Зато здесь возможна иная неприятность: модуль суммы (ее мантисса) может превзойти допустимую границу и "залезть" в знаковый разряд, испортив его. Например, при сложении байтовых чисел 127 и 2 получается величина 129 = 100001001b, представляющая дополнительный код числа -127 (=256-129). Хотя результат здесь получился и неправильным, процессор не фиксирует ошибку, но зато заносит 1 в флаг переполнения OF (если "переполнения мантиссы" не было, в OF записывается 0). Анализируя затем этот флаг, можно "поймать" такую ошибку.

Таким образом, сложение (вычитание) знаковых и беззнаковых чисел производится по одному и тому же алгоритму. При этом ПК не "знает", какие числа (со знаком или без) он складывает; в любом случае он складывает их как беззнаковые числа и в любом случае формирует флаги CF и OF. А вот как интерпретировать слагаемые и сумму, на какой из этих флагов обращать внимание - это личное дело автора программы.

Что касается умножения и деления знаковых и беззнаковых чисел, то они выполняются по разным алгоритмам, разными машинными командами. Однако и у этих операций есть ряд особенностей. При умножении байтов(слов) первый сомножитель обязан находиться в регистре AL (AX), результатом же умножения является слово (двойное слово), которое заносится в регистр AX (регистры DX и AX). Тем самым при умножении сохраняются все цифры произведения. При делении байтов (слов) первый операнд (делимое) должен быть словом (двойным словом) и обязан находиться в регистре AX (регистрах DX и AX). Результатом деления являются две величины размером в байт (слово) - неполное частное (div) и остаток от деления (mod); неполное частное записывается в регистр AL (AX), а остаток - в регистр AH (DX).

1.3.2. Сегментирование адресов в ПК

В ПК ради сокращения размера команд используется базирование адресов. Что это? В ЭВМ, память которой имеет 2k ячеек для ссылок на них должны быть к - разрядные адреса. Их называют абсолютными или физическими (для 8086). Неудобно когда k>числа разрядов процессора. Память ПК условно делится на участки, которые названы сегментами. Начальные адреса сегментов могут быть любыми и для 8086 ограничены 64 Кб, для 386 - все 4Гб. Тогда абсолютный адрес можно представить в виде суммы А=В+ofs. Где В - база сегмента, к которому относится ячейка А, а ofs - смещение (offset) или относительный адрес ячейки, то есть ее адрес, отсчитанный от начала сегмента, то есть базы. По принципам 16+8=18. В качестве сегментных регистров - CS, DS, SS, ES. Например командой mov можно пересылать мov ax,bx, mov si,di, mov es,ax, mov ax,188. Нельзя mov cs,ax. В память - mov ax, es:x адрес х - по регистру es. Адрес сегмента умножается на 16 (10Н). Если адрес базы - 12340Н, то в сегментном регистре будет хранится 1234Н. Если ES=1234Н то адресная пара ES:53Н задает абсолютный адрес 16*1234Н+53Н=10Н*1234Н=12340Н+53Н=12387Н. Адрес начала сегмента всегда кратен 16.

1.3.3. Стек

Стек - хранилище со следующим принципом работы. Элемент, записанный в стек последним, считывается из него первым. В ПК для стека можно отвести любую область памяти, но к ней - требования как к сегменту - не более 64к и адрес - кратен 16. Нервый элемент - в ячейку с наибольшим адресом. Начало - фиксировано(низ). А верх -SP. Push ax, pop es, pushf, popf, pusha, popa.

Представление команд процессора

1.4.1. Общие сведения

Машинные команды ПК занимают от 1 до 6 байтов. Код операции (КОП) занимает один или два первых байта команды. В ПК столь много различных операций, что для них не хватает 256 различных кодов, которые можно представить в одном байт. Поэтому некоторые операции объединяются в группу и им дается один и тот же КОП, во втором же байте этот код уточняется. Кроме того, во втором байте указываются типы операндов и способы их адресации. В остальных байтах команды указываются ее операнды.

Команды ПК могут иметь от 0 до 3 операндов. Размер операндов - байт или слово (редко - двойное слово). Операнд может быть указан в самой команде (это так называемый непосредственный операнд), либо может находится в одном из регистров ПК и тогда в команде указывается этот регистр, либо может находиться в ячейке памяти и тогда в команде тем или иным способом указывается адрес этой ячейки. Некоторые команды требуют, чтобы их операнд находился в фиксированном месте (например, в регистре AX), и тогда операнд явно не указывается в команде. Результат выполнения команды помещается в регистр или ячейку памяти, откуда берется один из операндов. Например, большинство команд с двумя операндами реализуют действие op := op1 * op2,

где op1 - регистр или ячейка памяти, а op2 - непосредственный операнд, регистр или ячейка памяти, а * - операция, заданная КОПом.

1.4.2. Модификация адресов

Адрес операнда разрешено модифицировать по одному или двум регистрам. В первом случае в качестве регистра-модификатора разрешено использовать регистр BX, BP, SI или DI (и никакой иной). Во втором случае один из модификаторов обязан быть регистром BX или BP, а другой -регистром SI или DI; одновременная модификация по BX и BP или SI и DI недопустима. Регистры BX и BP обычно используются для хранения базы (начального адреса) некоторого участка памяти (скажем, массива) и потому называются базовыми регистрами, а регистры SI и DI часто содержат индексы элементов массива и потому называются индексными регистрами.

Однако такое распределение ролей необязательно, и, например, в SI может находиться база массива, а в BX - индекс элемента массива.

В ASM адреса в командах записываются в виде одной из следующих конструкции:

A, A[M] или A[M1][M2],

где A - адрес, M - регистр BX, BP, SI или DI, M1 - регистр BX или BP, а M2 - регистр SI или DI. Во второрм и третьем варианте A может отсутствовать, в этом случае считается, что A=0.

При выполнении команды процессор прежде всего вычисляет т.н. исполнительный (эффективный) адрес - как сумму адреса, заданного в команде, и текущих значений указанных регистров-модификаторов, причем все эти величины рассматриваются как неотрицательные и суммирование ведется по модулю 216 ([r] означает содержимое регистра r):

A : Aисп = A

A[M] : Aисп = A+[M] (mod 216)

A[M1][M2]: Aисп = A+[M1]+[M2] (mod 216)

Полученный таким образом 16-разрядный адрес определяет т.н. смещение - адрес, отсчитанный от начала некоторого сегмента (области) памяти. Перед обращением к памяти процессор еще добавляет к смещению начальный адрес этого сегмента (он хранится в некотором сегментном регистре), в результате чего получается окончательный 20-разрядный адрес, по которому и происходит реальное обращение к памяти.

1.5. Форматы команд

Форматы машинных команд в ПК достаточно разнообразны. Для примера рассмотрим лишь основные форматы команд с двумя операндами.

1.5.1. Формат «регистр - регистр»

Формат «регистр - регистр» (2 байта):

КОП
	

d
	

w

 

7 2 1 0

11
	

reg1
	

reg2

 

7 6 5 3 2 0

Команды этого формата описывают обычно действие reg1:=reg1*reg2 или reg2:=reg2*reg1, где reg1 и reg2 - регистры общего назначения. Поле КОП первого байта указывает на операцию (*), которую надо выполнить. Бит w определяет размер операндов, а бит d указывает, в какой из двух регистров записывается результат:

ì 1- слова ì 1 - reg1:=reg1*reg2

w = í d = í

î 0 - байты î 0 - reg2:=reg2*reg1

Во втором байте два левых бита фиксированы (для данного формата), а трех-битовые поля reg1 и reg2 указывают на регистры, учавствующие в операции, согласно следующей таблице:

reg w=1 w=0 reg w=1 w=0

000 AX AL 100 SP AH

001 CX CL 101 BP CH

010 DX DL 110 SI DH

011 BX BL 111 DI BH

 

1.5.2. Формат «регистр - память»

Формат «регистр - память» (2-4 байта) :

КОП
	

d
	

w
	

mod
	

reg
	

mem
	

adr(0-2 байта)

7 2 1 0
	

7 6 5 3 2 0
	

7 0
	

	

	

	

 

Эти команды описывают операции reg:=reg*adr или adr:=adr*reg, где reg - регистр, а adr - адрес ячейки памяти. Бит w первого байта определяет размер операндов, а бит d указывает, куда записывается результат: в регистр (d=1) или в ячейку памяти (d=0). Трехбитовое поле reg второго байта указывает операнд - регистр, двухбитовое поле mod определяет, сколько байтов в команде занимает операнд - адрес (00 - 0 байтов, 01 - 1 байт, 10 - 2 байта), а трехбитовое поле mem указывает способ модификации этого адреса. В следующей таблице указаны правила вычисления исполнительного адреса в зависимости от значений полей mod и mem (a8 - адрес размером в байт, a16 - размером в слово, [r] - содержимое регистра r):

mem \ mod 00 01 10

000 [BX]+[SI] [BX]+[SI]+a8 [BX]+[SI]+a16

001 [BX]+[DI] [BX]+[DI]+a8 [BX]+[DI]+a16

010 [BP]+[SI] [BP]+[SI]+a8 [BP]+[SI]+a16

011 [BP]+[DI] [BP]+[DI]+a8 [BP]+[DI]+a16

100 [SI] [SI]+a8 [SI]+a16

101 [DI] [DI]+a8 [DI]+a16

110 a16 [BP]+a8 [BP]+a16

111 [BX] [BX]+a8 [BX]+a16

 

Замечания. Если в команде не задан адрес, то он считается нулевым. Если адрес задан в виде байта (a8), то он автоматически расширяется до слова (а16). Случай mod=00 и mem=110 указывает на отсутствие регистров - модификаторов, причем адрес должен иметь размер слова. Случай mod=11 соответствует формату «регистр - регистр».

1.5.3. Формат «регистр - непосредственный операнд»

Формат «регистр - непосредственный операнд» (3-4 байта):

КОП
	

s
	

w
	

11
	

КОП’
	

reg
	

im(1- 2 байта)

 

Команды этого формата описывают операции reg:=reg*im (im - непосредственный операнд). Бит w указывает на размер операндов, а поле reg - на регистр - операнд. Поле КОП в первом байтеопределяет лишь группу операций, в которую входит операция данной команды, уточняет же операцию поле КОП’ из второго байта. Непосредственный операнд может занимать 1 или 2 байта (в зависимости от значения бита w), при этом операнд размером в слово записывается в команде в «перевернутом» виде. Ради экономии памяти в ПК предусмотрен случай, когда в операции над словами непосредственный операнд может быть задан байтом (на это указывает 1 в бите s при w=1), и тогда перед выполнением операции байт автоматически расширяется до слова.

1.5.4. Формат «память - непосредственный операнд»

Формат «память - непосредственный операнд» (3-6 байтов):

КОП
	

s
	

w
	

11
	

КОП’
	

mem
	

adr(0- 2 байта)
	

im(1-2 байта)

Команды этого формата описывают операции типа adr:=adr*im. Смысл всех полей - тот же, что и в предыдущих форматах.

Уже из рассмотренных форматов команд видно, что записывать машинные команды ПК в цифровом виде - вещь чрезвычайно неприятная. Сложности возникают и при записи данных, например, знаковые числа приходится представлять в дополнительном коде, а затем еще и «переворачивать». Поэтому нужен какой-то иной, более удобный способ записи команд и данных. И таким способом является язык ассемблера.

ГЛАВА 2

ОБЩИЕ СВЕДЕНИЯ О ЯЗЫКЕ АССЕМБЛЕРА

2.1 Основные понятия

Программировать на машинном языке неудобно и сложно. Ассемблер представляет собой символьную запись машинного языка. Вместо цифровых кодов операций указывают их словесные названия, вместо адресов - имена, а числа можно заносить в десятичной системе. Написанную в таком виде программу передают транслятору, который переводит ее в машинный язык.

2.1.1. Идентификаторы

Идентификаторы - символьные обозначения объектов программы: переменных, меток, названий операций и т.п. И. - последовательность из латинских букв (больших и малых), цифр и знаков ?.@_$. Ограничения на И. ¾ длина может быть любой, но значащие - лишь первые 31 символ, ¾ не должен начинаться с цифры ¾ точка - только первым символом,¾ одноименные большие и малые буквы - эквивалентны. Русские не допустимы. Делятся на служебные (зарезервированные - reserved) слова и имена. Первые определены заранее и имеют определенный смысл, например обозначают регистры (ах, cs) названия команд (mov, xor), все остальные И. называются именами и ими можно пользоваться по усмотрению.

2.1.2. Запись целых чисел в ассемблере

Могут быть записаны в десятичной, двоичной, щестнадцатиричной и восьмиричной системах счисления. Десятичные числа записываются как обычно, или с добавлением буквы d. После двоичного числа добавляется b, после щестнадцатиричного - h, а после восьмеричного о или q. Если hex начинается с буквы (цифры, обозначаемой буквой), то перед ним обязательно должен стоять ноль.

2.1.2. Символьные данные

Символы заключаются в кавычки или апострофы ²А² или ¢А¢ не ²Ы¢. Строки (последовательности символов) также ¢перспектива¢. Заметим ¾ в качестве символов можно использовать буквы русского алфавита,¾ в строках одноименные большие и малые буквы не отождествляются, ¾ кавычки: ‘don’’t’ «don’t».

2.1.3. Предложения

Программа на ассемблере состоит из предложений, каждое из которых записывается на отдельной строке. <предложение>... Переносить предложение на следующую строку или записывать два предложения на одной строке нельзя. Если более 131 символа, то 132-й и далее - игнорируются. Правила расстановки пробелов:

¾ пробел обязателен между стоящими рядом идентификаторами и/или числами,

¾ внутри идентификаторов и чисел пробелы недопустимы,

¾ там где допустим один пробел, допустимо и несколько пробелов подряд. Предложения в ассемблере делятся на три группы по смыслу: комментарии, команды, директивы (приказы ассемблеру). Рассмотрим.

комментарии. Не отражаются на ходе выполнения программы, игнорируются компилятором и предназначены для людей. Могут быть любые символы. Комментарием считается любая строка, начинающаяся со знака ; или пустая строка. Возможен многострочный комментарий COMMENT <маркер> <текст>. В качестве комментария берется первый за словом COMMENT символ, отличный то пробела COMMENT * бред* бред.

Команды. Это символьная форма записи машинных команд.

[<метка>:] <мнемокод> [<операнды>] [;<комментарий>]

Метка с двоеточием, а также точка с запятой и комментарий могут отсутствовать.

метка синтаксически - имя команды, ее можно использовать в командах перехода на данную команду.. Если метка есть то после нее обязательно двоеточие нужна для ссылок, например для перехода на эту команду. В строке может стоять только метка, метит следующую строку. Если длинная метка или если необходимо пометить строку несколькими метками.

Мнемокод (мнемонический код) является обязательной частью команды и указывает ту операцию, которую должна выполнить команда. Записывается в символьной форме.

Операнды, если они есть отделяются друг от друга запятыми.

Комментарий - после знака ; не влияет на смысл команды, а лишь поясняет ее. Действителен для данной строки.

Регистры указываются своими именами, например:

MOV AX,SI ;оба операнда - регистры

Непосредственные операнды задаются константными выражениями (их значениями являются константы-числа), например:

MOV BH,5 ;5 - непосредственный операнд

MOV DI,SIZE X ;SIZE X (число байтов, занимаемых переменной X) - ;непосредственный операнд

Адреса описываются адресными выражениями (например, именами переменных), которые могут быть модифицированы по одному или двум регистрам; например, в следующих командах первые операнды задают адреса:

MOV X,AH

MOV X[BX][DI],5

MOV [BX],CL

 

2.2. Директивы языка Ассемблер

2.2.1. Общие понятия

Помимо машинных команд в программе на ЯА надо указывать и другие вещи. Например, надо сообщать, какие константы и переменные используются в программе и какие имена мы им дали. Это делается с помощью предложений, называемых приказами ассемблеру или директивами.

Синтаксис директив следующий:

[<имя>] <название директивы> [<операнды>] [< ; комментарий>]

Пример: X DB 10, -5, 0FFh ; массив X

Как видно, формат директив в целом совпадает с форматом команд. Единственное отличие - в директиве после имени, если оно есть, не ставится двоеточие. Имя, указываемое в начале директивы, - это, как правило, имя константы или переменной, описываемой данной директивой. В нашем примере X - это имя переменной - массива из трех элементов. Названия директив, как и мнемокоды, - служебные слова. При этом заранее известно, какие служебные слова обозначают директивы, а какие - мнемокоды, и путаницы здесь нет. Названия директив будут указываться по мере знакомства с директивами. Остальные части директивы (операнды и комментарий) записываются также, как и в командах.

2.2.2 Директивы определения данных

Для того чтобы в программе на ASM зарезервировать ячейки памяти под константы и переменные, необходимо воспользоваться директивами определения данных - с названиями DB (описывает данные размером в байт), DW (размером в слово) и DD (размером в двойное слово). (Директивы, или команды ассемблеру, - это предложения программы, которыми ее автор сообщает какую-то информацию ассемблеру или просит что-то сделать дополнительно, помимо перевода символьных команд на машинный язык.)

В простейшем случае в директиве DB, DW или DD описывается одна константа, которой дается имя для последующих ссылок на нее. По этой директиве ассемблер формирует машинное представление константы (в частности, если надо, "переворачивает" ее) и записывает в очередную ячейку памяти. Адрес этой ячейки становится значением имени: все вхождения имени в программу ассемблер будет заменять на этот адрес. Имена, указанные в директивах DB, DW и DD, называются именами переменных (в отличие от меток - имен команд).

В ASM числа записываются в нормальном (неперевернутом) виде в cистемах счисления с основанием 10, 16, 8 или 2. Десятичные числа записываются как обычно, за шестнадцатиричным числом ставится буква h (если число начинается с "цифры" A, B, ..., F, то вначале обязателен 0), за восьмиричным числом - буква q или o, за двоичным числом - буква b.

Примеры:

A DB 162 ;описать константу-байт 162 и дать ей имя A

B DB 0A2h ;такая же константа, но с именем B

С DW -1 ;константа-слово -1 с именем С

D DW 0FFFFh ;такая же константа-слово, но с именем D

E DD -1 ;-1 как двойное слово

Константы-символы описываются в директиве DB двояко: указывается либо код символа (целое от 0 до 255), либо сам символ в кавычках (одинарных или двойных); в последнем случае ассемблер сам заменит символ на его код. Например, следующие директивы эквивалентны (2A - код звездочки в ASCII):

CH DB 02Ah

CH DB '*'

CH DB "*"

Константы-адреса, как правило, задаются именами. Так, по директиве

ADR DW CH

будет отведено слово памяти, которому дается имя ADR и в которое запишется адрес (смещение), соответствующий имени CH. Если такое же имя описать в директиве DD, то ассемблер автоматически добавит к смещению имени его сегмент и запишет смещение в первую половину двойного слова, а сегмент - во вторую половину.

По любой из директив DB, DW и DD можно описать переменную, т.е. отвести ячейку, не дав ей начального значения. В этом случае в правой части директивы указывается вопросительный знак:

F DW ? ;отвести слово и дать ему имя F, ничего в этот байт не записывать

В одной директиве можно описать сразу несколько констант и/или переменных одного и того же размера, для чего их надо перечислить через запятую. Они размещаются в соседних ячейках памяти. Пример:

G DB 200, -5, 10h, ?, 'F'

Имя, указанное в директиве, считается именующим первую из констант. Для ссылок на остальные в MASM используются выражения вида <имя>+<целое>; например, для доступа к байту с числом -5 надо указать выражение

G+1, для доступа к байту с 10h - выражение G+2 и т.д.

Если в директиве DB перечислены только символы, например:

S DB 'a','+','b'

тогда эту директиву можно записать короче, заключив все эти символы в одни кавычки:

S DB 'a+b'

И, наконец, если в директиве описывается несколько одинаковых констант (переменных), то можно воспользоваться конструкцией повторения

k DUP(a,b,...,c)

которая эквивалентна повторенной k раз последовательности a,b,...,c.

Например, директивы

V1 DB 0,0,0,0,0

V2 DW ?,?,?,?,?,?,?,?,?,'a',1,2,1,2,1,2,1,2

можно записать более коротко таким образом:

V1 DB 5 DUP(0)

V2 DW 9 DUP(?), 'a', 4 DUP(1,2)

2.2.3. Директивы присваивания и эквивалентности

Директива эквивалентности - EQU (Equal, равно), имеет синтаксис

<имя> equ <операнд> - обязательно имя и один операнд. Директива означает, что указанному операнду присваивается указанное имя и при вхождении этого имени в текст программы ассемблер заменяет его на этот операнд, например если есть

name equ ‘pers’ то ассемблер будет рассматривать предложение

nm db name как nm db ‘pers’.

Директива носит чисто информационный характер и при ее появлении ассемблер ничего не заносит в машинную программу. Можно указывать имя a dw 55 b equ a c dw b ; то же что c dw a. Можно указывать имена регистров rez1 equ bx. Если справа - константное выражение, то слева - имя константы. N equ 10 k equ 3*n-1. Далее директива xx db k dup (?) то же что xx db 29 dup (?) можно также wp equ word ptr.

Директива присваивания. <имя> = <константное выражение> определяет константу с именем, указанным в левой части и с числовым значением, равным выражению справа. В отличие от констант, определенных с помощью директивы equ данная константа может менять свое значение, обозначая в разных частях программы разные числа. Так, k=10 a db k ; same as a db 10 k=k+5 s db k ; same as s db 15. Нельзя q equ 1 q equ 2 нельзя w equ 1 w=2 нельзя e=1 e equ 2

K=1

n equ k

a db n ;a=k

k=2

b db n ;b=2
	

k=1

n equ k+10

c dw n ; c=11

k=2

s dw n ;d=11

 

2.3. Ссылки назад и вперед.

Теперь сделаем несколько замечаний о метках и именах. Во-первых, метки команд и имена (констант, переменных и т.п.), указываемые в директивах, - это, вообще говоря, разные вещи как по смыслу, так и по ряду формальных признаков. Однако, если не вдаваться в детали, то метки можно рассматривать как имена команд. Поэтому в дальнейшем под термином “имя” мы будем обычно понимать как имена переменных, так и метки. Во-вторых, появление имени в начале команды или директивы считается описанием данного имени. В ЯА действует общее правило: каждое имя должно быть описано только раз, т.е. в программе не должно быть двух предложений с одним и тем же именем вначале. (Из этого правила есть исключения, они будут оговариваться явно.) В-третьих, если в языках высокого уровня действует правило «сначала опиши и лишь затем используй», то в ЯА такого правила нет и именем можно пользоваться (ссылаться на него) как до его описания, так и после описания. Поэтому допустимы оба случая:

A db 1
	

	

NEG A
	

...............
	

ссылка назад
	

..............
	

ссылка вперед

neg A
	

	

A DB 1
	

 

Чтобы различать эти случаи, вводят термины «ссылка вперед» и «ссылка назад». Ссылка назад - это ссылка на имя, которое по тексту программы описано раньше, а ссылка вперед - это ссылка на имя, которое будет описано позже. При трансляции ассемблер просматривает текст программы на ЯА сверху вниз. Когда он встречает ссылку на имя, которое уже было описано, то он, имея к этому моменту всю информацию об имени, может правильно оттранслировать данную ссылку. Но если ему встретилась ссылка вперед, т.е. имя, которое еще не описано и о котором он пока ничего не знает, то он не всегда может правильно оттранслировать эту ссылку и потому здесь нередко возникают проблемы. В связи с этим, хотя в целом ЯА и допускает ссылки вперед, в некоторых случаях такие ссылки запрещаются (эти случаи будут оговариваться явно), поэтому лучше всего стараться не использовать ссылки вперед.

Операнд в директиве db - константное выражение с допустимым значением -128¸255. Возможны следующие варианты записи директивы:

q db 41h = q db ‘a’

qq db ‘as magic’ - операнд-строка

mass db 1,2,3,55h,-1,’power’

Операнд - конструкция повторения DUP

zer db 0,0,0,0,0,0,0,0,0 = zer db 9 dup (0)

va db 32h, 3 dup (‘qw’,1,?) va db 32h,‘qw’,1,?, ‘qw’,1,?, ‘qw’,1,?

Adb 20 dup( 30 dup (?))

2.4. Оператор указания типа (PTR)

При записи команд в символьной форме необходимо внимательно следить за правильным указанием типа (размера) операндов, чтобы не было ошибок. Тип обычно определяется по внешнему виду одного из них, например:

MOV AH,5 ;пересылка байта, т.к. AH - байтовый регистр

MOV AX,5 ;пересылка слова, т.к. AX - 16-битовый регистр

;(операнд 5 может быть байтом и словом, по нему

;нельзя определить размер пересылаемой величины)

MOV [BX],300 ;пересылка слова, т.к. число 300 не может быть

;байтом

Если по внешнему виду можно однозначно определить тип обоих операндов, тогда эти типы должны совпадать, иначе ассемблер зафиксирует ошибку. Примеры:

MOV DS,AX ;оба операнда имеют размер слова

MOV CX,BH ;ошибка: регистры CX и BH имеют разные размеры

MOV DL,300 ;ошибка: DL - байтовый регистр, а число 300 не

;может быть байтом

Возможны ситуации, когда по внешнему виду операндов нельзя определить тип ни одного из них, как, например, в команде

MOV [BX],5

Здесь число 5 может быть и байтом, и словом, а адрес из регистра BX может указывать и на байт памяти, и на слово.

Отметим, что если некоторый адрес А необходимо модифицировать, скажем по регистру SI, то в АЯ это записывается так: A[SI]. Исполнительный адрес в этом случае вычисляется по формуле Аисп=А+[SI]. В частности, при А=0 эта запись имеет вид [SI] (0 не указывается) и задает исполнительный адрес, равный содержимому регистра SI: Аисп=[SI]. С учетом этого рассмотрим такую задачу. Пусть в регистре SI находится адрес некоторой ячейки памяти и требуется записать 0 в эту ячейку. Тогда, казалось бы, такое обнуление можно сделать с помощью команды MOV [SI] , 0.

Однако это не так. Дело в том, что по этой команде нельзя понять, какого размера ноль пересылается, поскольку второй операнд может обозначать ноль как размером в байт (00h), так и размером в слово (0000h), а что касается первого операнда, то адрес из регистра SI может быть адресом ячейки как размером в байт, так и размером в слово (с одного и того же адреса могут начинаться ячейки разных размеров). Итак, в этой команде ни по первому, ни по второму операнду нельзя определить размер пересылаемой величины, поэтому компилятор ассемблера не сможет определить, на какую конкретную машинную команду заменять эту символьную команду. В подобных ситуациях ассемблер фиксирует ошибку, сообщая, что типы операндов неизвестны.

Чтобы не было этой ошибки, автор программы должен явно указать тип хотя бы одного из операндов команды. Для этого в АЯ введен оператор указания типа PTR (от pointer, указатель), который записывается следующим образом:

<тип> PTR <выражение>

где <тип> - это BYTE, WORD или DWORD (есть и другие варианты, но мы их пока не рассматриваем), а выражение может быть константным или адресным. Если указано константное выражение, то оператор указывает на то, что значение этого выражения (число) должно рассматриваться ассемблером как величина указанного типа (размера); например, BYTE PTR 0 - это ноль как байт, а WORD PTR 0 - это ноль как слово (запись BYTE PTR 300 ошибочна, т.к. число 300 не может быть байтом). Отметим, что в этом случае оператор PTR относится к константным выражениям. Если же в PTR указано адресное выражение, то оператор «говорит», что адрес, являющийся значением выражения, должен восприниматься ассемблером как адрес ячейки указанного типа (размера); например: WORD PTR A - адрес А обозначает слово (байты с адресами А и А+1). В данном случае оператор PTR относится к адресным выражениям. С использованием оператора PTR наша задача решается так: если мы имеем в виду обнуление байта по адресу из регистра SI, то для этого необходимо использовать команду:

MOV BYTE PTR [SI], 0 или MOV [SI], BYTE PTR 0,

а если надо переслать нулевое слово, то команду:

MOV WORD PTR [SI], 0 или MOV [SI], WORD PTR 0.

Отметим, что обычно принято уточнять тип операнда-адреса, а не тип непосредственного операнда. Оператор PTR полезен еще в одной ситуации - когда надо не уточнить тип операнда, а изменить его. Пусть, к примеру, Z - переменная размером в слово: Z DW 1234h ; Z: 34h, Z+1: 12h

и надо записать ноль не во все это слово, а только в его первый байт - в тот, где находится величина 34h. Так вот, сделать это командой MOV Z, 0 нельзя, т.к. по ней 0 запишется в оба байта, потому, что имя Z описано в директиве DW и потому, как мы уже знаем, получает тип WORD: TYPE Z=WORD. Когда ассемблер определяет размер операнда команды, в качестве которого указано имя переменной, он учитывает тип, полученный именем при описании. Поэтому в нашем случае ассемблер и считает, что пересылается нулевое слово. Обычно это так и должно быть, но сейчас нас это не устраивает, нам сейчас нужно, чтобы ассемблер рассматривал Z как имя байта. Вот такое изменение типа имени и позволяет сделать оператор PTR:

MOV BYTE PTR Z,0 ; Z: 00h, Z+1: 12h

Здесь мы сказали ассемблеру, чтобы он игнорировал тот тип имени Z, который был приписан ему при описании, и считал, что имя Z обозначает байт. (Отметим, что такое изменение типа локально, оно действует только в данной команде.) Аналогичная ситуация возникает, если мы хотим получить доступ ко второму байту переменной Z. Например, для записи 15 в этот байт нельзя использовать команду MOV Z+1,15 , т.к. считается, что адрес Z+1 обозначает слово. Это общее правило в ЯА: адрес вида <имя>±<целое> имеет тот же тип, что и <имя>. Поэтому число 15 запишется в два байта - с адресами Z+1 и Z+2. Если же мы хотим изменить только байт по адресу Z+1, тогда надо воспользоваться оператором PTR: MOV BYTE PTR (Z+1),15

Здесь конструкция BYTE PTR (Z+1) «говорит», что Z+1 надо рассматривать как адрес байта, а не слова. Отметим, что в ЯА оператор PTR по старшинству выполняется до оператора сложения, поэтому запись BYTE PTR Z+1 трактуется как (BYTE PTR Z)+1. Однако в данном конкретном случае старшинство операторов не играет никакой роли, т.к. обе записи - BYTE PTR (Z+1) и BYTE PTR Z+1 - эквивалентны по смыслу: в первом случае мы сначала увеличиваем адрес Z на 1 и только затем сообщаем, что Z+1 надо рассматривать как адрес байта, а во втором случае мы сначала сообщаем, что Z - это адрес байта, и лишь затем увеличиваем его на 1 (при этом «байтовость» адреса сохраняется). Итак, оператор PTR используется в следующих ситуациях: когда типы операндов команд неизвестны и потому надо указать явно тип одного из операндов, и когда нас не устраивает тип, приписанный имени при его описании, и поэтому мы должны указать нужный нам тип.

2.5. Команда XCHG

В машинных программах приходится довольно часто переставлять местами какие-то две величины, и хотя такую перестановку можно реализовать только с помощью команды MOV, в ПК введена специальная команда для этого:

Перестановка (exchange): XCHG op1,op2

Эта команда меняем местами значения своих операндов (они должны быть либо байтами, либо словами): op1 ó op2. Флаги при этом не меняются. Пример:

MOV AX,62 ;AX=62

MOV SI,135 ;SI=135

XCHG AX,SI ;AX=135, SI=62

Допустимые типы операндов команды XCHG:

op1
	

op2
	

r8
	

r8, m8
	

перестановка байтов

m8
	

r8
	

r16
	

r16, m16
	

перестановка слов

m16
	

r16
	

Как видно, не допускается перестановка содержимого двух ячеек памяти. Если все-таки надо сделать такую перестановку, то это реализуется через какой-нибудь регистр. Например, поменять местами значения байтовых переменных X и Y можно так: MOV AL,X ;AL=X

XCHG AL,Y ;AL=Y, Y=X

MOV X,AL ;X=Y (исходное значение).

2.6. Сегментирование

2.6.1 Сегменты памяти. Сегментные регистры

Первые модели ПК имели оперативную память объемом 216 байтов (64Кб) и потому использовали 16-битовые адреса. В последующих моделяхпамять была увеличена до 220 байтов (1Мб=1000Кб), для чего уже необходимы 20-битовые адреса. Однако в этих ПК ради сохранения преемственности были сохранены 16-битовые адреса: именно такие адреса хранятся в регистрах и указываются в командах, именно такие адреса получаются в результате модмфикации по базовым и индексным регистрам. Как же удается 16-битовыми адресами ссылаться на 1Мб памяти?

Эта проблема решается с помощью сегментирования адресов (неявного базирования адресов). В ПК вводится понятие "сегмент памяти". Так называется любой участок памяти размером до 64Кб и с начальным адресом, кратным 16. Абсолютный (20-битовый) адрес A любой ячейки памяти можно представить как сумму 20-битового начального адреса (базы) B сегмента, которому принадлежит ячейка, и 16-битового смещения D - адреса этой ячейки, отсчитанного от начала сегмента: A=B+D. (Неоднозначность выбора сегмента не играет существенной роли, главное - чтобы сумма B и D давала нужный адрес.) Адрес B заносится в некоторый регистр S, а в команде, где должен быть указан адрес A, вместо него записывается пара из регистра S и смещения D (в MASM такая пара, называемая адресной парой или указателем, записывается как S:D). Процессор же устроен так, что при выполнении команды он прежде всего по паре S:D вычисляет абсолютный адрес A как сумму содержимого регистра S и смещения D и только затем обращается к памяти по этому адресу A. Вот так, заменяя в командах абсолютные адреса на адресные пары, и удается адресовать всю память 16-битовыми адресами (смещениями). В качестве регистра S разрешается использовать не любой регистр, а только один из 4 регистров, называемых сегментными: CS, DS, SS и ES. В связи с этим одновременно можно работать с 4 сегментами памяти: начало одного из них загружается в регистр CS и все ссылки на ячейки этогосегмента указываются в виде пар CS:D, начало другого заносится в DS и все ссылки на его ячейки задаются в виде пар DS:D и т.д. Если одновременно надо работать с большим числом сегментов, тогда нужно своевременно спасать содержимое сегментных регистров и записывать в них начальные адреса пятого, шестого и т.д. сегментов.

Отметим, что используемые сегменты могут быть расположены в памяти произвольным образом: они могут не пересекаться, а могут пересекаться и даже совпадать. Какие сегменты памяти использовать, в каких сегментных регистрах хранить их начальные адреса - все это личное дело автора машинной программы.

Как и все регистры ПК, сегментные регистры имеют размер слова. Поэтому возникает вопрос: как удается разместить в них 20-битовые начальные адреса сегментов памяти? Ответ такой. Поскольку все эти адресакратны 16 (см. выше), то в них младшие 4 бита (последняя 16-ричная цифра) всегда нулевые, а потому эти биты можно не хранить явно, а лишь подразумевать. Именно так и делается: в сегментном регистре всегда хранятся только первые 16 битов (первые четыре 16-ричные цифры) начального адреса сегмента (эта величина называется номером сегмента или просто сегментом). При вычислении же абсолютного адреса A по паре S:D процессор сначала приписывает справа к содержимому регистра S четыре нулевых бита (другими словами, умножает на 16) и лишь затем прибавляет смещение D, причем суммирование ведется по модулю 220:

Aабс = 16×[S]+D (mod 220)

Если, например, в регистре CS хранится величина 1234h, тогда адресная пара 1234h:507h определяет абсолютный адрес, равный 16*1234h+507h =12340h+507h = 12847h.

2.6.2 Сегментные регистры по умолчанию

Согласно описанной схеме сегментирования адресов, замену абсолютных адресов на адресные пары надо производить во всех командах, имеющих операнд-адрес. Однако разработчики ПК придумали способ, позволяющий избежать выписывания таких пар в большинстве команд. Суть его в том, что заранее договариваются о том, какой сегментный регистр на какой сегмент памяти будет указывать, и что в командах задается только смещение: не указанный явно сегментный регистр автоматически восстанавливается согласно этой договоренности. И только при необходимости нарушить эту договоренность надо полностью указывать адресную пару.

Что это за договоренность? Считается, что регистр CS всегда указывает на начало области памяти, в которой размещены команды программы (эта область называется сегментом команд или сегментом кодов), и потому при ссылках на ячейки этой области регистр CS можно не указывать явно, он подразумевается по умолчанию. (Отметим попутно, что абсолютный адрес очередной команды, подлежащей выполнению, всегда задается парой CS:IP: в счетчике команд IP всегда находится смещение этой команды относительно адреса из регистра CS.) Аналогично предполагается, что регистр DS указывает на сегмент данных (область памяти с константами, переменными и другими величинами программы), и потому во всех ссылках на этот сегмент регистр DS можно явно не указывать, т.к. он подразумевается по умолчанию. Регистр SS, считается, указывает на стек - область памяти, доступ к которой осуществляется по принципу "последним записан - первым считан" (см. далее), и потому все ссылки на стек, в которых явно не указан сегментный регистр, по умолчанию сегментируются по регистру SS. Регистр ES считается свободным, он не привязан ни к какому сегменту памяти и его можно использовать по своему усмотрению; чаще всего он применяется для доступа к данным, которые не поместились или сознательно не были размещены в сегменте данных.

С учетом такого распределения ролей сегментных регистров машинные программы обычно строятся так: все команды программы размещаются в одном сегменте памяти, начало которого заносится в регистр CS, а все данные размещаются в другом сегменте, начало которого заносится в регистр DS; если нужен стек, то под него отводится третий сегмент памяти, начало которого записывается в регистр SS. После этого практически во всех командах можно указывать не полные адресные пары, а лишь смещения, т.к. сегментные регистры в этих парах будут восстанавливаться автоматически.

Здесь, правда, возникает такой вопрос: как по смещению определить, на какой сегмент памяти оно указывает? Точный ответ приведен ниже , а в общих чертах он такой: ссылки на сегмент команд могут быть только в командах перехода, а ссылки практически во всех других командах (кроме строковых и стековых) - это ссылки на сегмент данных. Например, в команде пересылки

MOV AX,X

имя X воспринимается как ссылка на данное, а потому автоматически восстанавливается до адресной пары DS:X. В команде же безусловного перехода по адресу, находящемуся в регистре BX,

JMP BX

абсолютный адрес перехода определяется парой CS:[BX].

Итак, если в ссылке на какую-то ячейку памяти не указан явно сегментный регистр, то этот регистр берется по умолчанию. Явно же сегментные регистры надо указывать, только если по каким-то причинам регистр по умолчанию не подходит. Если, например, в команде пересылки нам надо сослаться на стек (скажем, надо записать в регистр AH байт стека, помеченный именем X), тогда нас уже не будет устраивать договоренность о том, что по умолчанию операнд команды MOV сегментируется по регистру DS, и потому мы обязаны явно указать иной регистр - в нашем случае регистр SS, т.к. именно он указывает на стек:

MOV AH,SS:X

Однако такие случаи встречаются редко и потому в командах, как правило, указываются только смещения. Отметим, что в MASM сегментный регистр записывается в самой команде непосредственно перед смещением (именем переменной, меткой и т.п.), однако на уровне машинного языка ситуация несколько иная. Имеется 4 специальные однобайтовые команды, называемые префиксами замены сегмента (обозначаемые как CS:, DS:, SS: и ES:). Они ставятся перед командой, операнд-адрес которой должен быть просегментирован по регистру, отличному от регистра, подразумеваемому по умолчанию. Например, приведенная выше символическая команда пересылки - это на самом деле две машинные команды:

SS:

MOV AH,X

2.6.3 Сегментирование, базирование и индексирование адресов

Поскольку сегментирование адресов - это разновидность модификации адресов, то в ПК адрес, указываемый в команде, в общем случае модифицируется по трех регистрам - сегментному, базовому и индексному. В целом, модификация адреса производится в два этапа. Сначала учитываются только базовый и индексный регистры (если они, конечно, указаны в команде), причем вычисление здесь происходит в области 16-битовых адресов; полученный в результате 16-битовый адрес называется исполнительным (эффективным) адресом. Если в команде не предусмотрено обращение к памяти (например, она загружает адрес в регистр), то на этом модификация адреса заканчивается и используется именно исполнительный адрес (он загружается в регистр). Если же нужен доступ к памяти, тогда на втором этапе исполнительный адрес рассматривается как смещение и к нему прибавляется (умноженное на 16) содержимое сегментного регистра, указанного явно или взятого по умолчанию, в результате чего получается абсолютный (физический) 20-битовый адрес, по которому реально и происходит обращение к памяти.

Отметим, что сегментный регистр учитывается только в "последний" момент, непосредственно перед обращением к памяти, а до этого работа ведется только с 16-битовыми адресами. Если учесть к тому же, что сегментные регистры, как правило, не указываются в командах, то можно вобщем-то считать, что ПК работает с 16-битовыми адресами.

Как уже сказано, если в ссылке на ячейку памяти не указан сегментный регистр, то он определяется по умолчанию. Это делается по следующим правилам.

1) В командах перехода адрес перехода сегментируется по регистру CS и только по нему, т.к. абсолютный адрес команды, которая должна быть выполнена следующей, всегда определяется парой CS:IP (попытка изменить в таких командах сегментный регистр будет безуспешной).

Отметим, что сегментиорвание по регистру CS касается именно адреса перехода, а не адреса той ячейки, где он может находиться. Например, в команде безусловного перехода по адресу, находящемуся в ячейке X:

JMP X

имя X сегментируется по регистру DS, а вот адрес перехода, взятый из ячейки X, уже сегментируется по регистру CS.

2) Адреса во всех других командах, кроме строковых (STOS, MOVS,

SCAS и CMPS), по умолчанию сегментируются:

- по регистру DS, если среди указанных регистров-модификаторов нет регистра BP;

- по регистру SS, если один из модификаторов - регистр BP.

Таким образом, адреса вида A, A[BX], A[SI], A[DI], A[BX][SI] и A[BX][DI] сегментируются по регистру DS, а адреса A[BP], A[BP][SI] и A[BP][DI] - по регистру SS, т.е. адреса трех последних видов используются для доступа к ячейкам стека.

3) В строковых командах STOS, MOVS, SCAS и CMPS, имеющих два операнда-адреса, на которые указывают индексные регистры SI и DI, один из операндов (на который указывает SI) сегментируется по регистру DS, адругой (на него указывает DI) - по регистру ES.

2.6.4 Программные сегменты. Директива ASSUME

Рассмотрим, как сегментирование проявляется в программах на MASM.

Для того чтобы указать, что некоторая группа предложений программы на MASM образуют единый сегмент памяти, они оформляются как программный сегмент: перед ними ставится директива SEGMENT, после них - директива ENDS, причем в начале обеих этих директив должно быть указано одно и то же имя, играющее роль имени сегмента. Программа же в целом представляет собой последовательность таких программных сегментов, в конце которой указывается директива конца программы END, например:

DT1 SEGMENT ;программный сегмент с именем DT1

A DB 0

B DW ?

DT1 ENDS

;

DT2 SEGMENT ;программный сегмент DT2

C DB 'hello'

DT2 ENDS

;

CODE SEGMENT ;программный сегмент CODE

ASSUME CS:CODE, DS:DT1, ES:DT2

BEG: MOV AX,DT2

MOV DS,AX

MOV BH,C

...

CODE ENDS

END BEG ;конец текста программы

Предложения программного сегмента ассемблер размещает в одном сегменте памяти (в совокупности они не должны занимать более 64Кб) начиная с ближайшего свободного адреса, кратного 16. Номер (первые 16 битов начального адреса) этого сегмента становится значением имени сегмента. В MASM это имя относится к константным выражениям, а не адресным, в связи с чем в команде MOV AX,DT2

второй операнд является непосредственным, поэтому в регистр AX будет записано начало (номер) сегмента DT2, а не содержимое начальной ячейки этого сегмента.

Имена же переменных (A, B, C) и метки (BEG) относятся к адресным выражениям, и им ставится в соответствие адрес их ячейки относительно "своего" сегмента: имени A соответствует адрес 0, имени B - адрес 1,

имени C - адрес 0, а метке BEG - адрес 0.

Все ссылки на предложения одного программного сегмента ассемблер сегментирует по умолчанию по одному и тому же сегментному регистру. По какому именно - устанавливается специальной директивой ASSUME. В нашем примере эта директива определяет, что все ссылки на сегмент CODE должны, если явно не указан сегментный регистр, сегментироваться по регистру CS, все ссылки на DT1 - по регистру DS, а все ссылки на DT2 - по регистру ES.

Встретив в тексте программы ссылку на какое-либо имя (например, на имя C в команде MOV AX,C), ассемблер определяет, в каком программном сегменте оно описано (у нас - в DT2), затем по информации из директивы ASSUME узнает, какой сегментный регистр поставлен в соответствие этому сегменту (у нас - это ES), и далее образует адресную пару иэ данного

регистра и смещения имени (у нас - ES:0), которую и записывает в формируемую машинную команду. При этом ассемблер учитывает используемое в ПК соглашение о сегментных регистрах по умолчанию: если в адресной паре, построенной им самим или явно заданной в программе, сегментный регистр совпадает с регистром по умолчанию, то в машинную команду заносится лишь смещение. Если, скажем, в нашем примере встретится команда MOV CX,B, тогда по имени В ассемблер построит пару DS:1, но раз операнд-адрес команды MOV по умолчанию сегментируется по регистру DS, то записывать этот регистр в машинную команду излишне и ассемблер записывает в нее только смещение 1.

Таким образом, директива ASSUME избавляет программистов от необходимости выписывать полные адресные пары не только тогда, когда используются сегментные регистры по умолчанию (как в случае с именем B), но тогда, когда в машинной команде нужно было бы явно указать сегментный регистр (как в случае с именем C). В MASM сегментный регистр в ссылке на имя требуется указывать лишь тогда, когда имя должно по каким-либо причинам сегментироваться по регистру, отличному от того, что постав-

лен в соответствие всему сегменту, в котором это имя описано.

Однако все это справедливо только при соблюдении следующих условий. Во-первых, директива ASSUME должна быть указана перед первой командой программы. В противном случае ассемблер, просматривающий текст программы сверху вниз, не будет знать, как сегментировать имена из команд, расположенных до этой директивы, и потому зафиксирует ошибку.

Во-вторых, в директиве ASSUME следует каждому сегменту ставить в соответствие сегментный регистр: если ассемблеру встретится ссылка на имя из сегмента, которому не соответствует никакой сегментный регистр, то он зафиксирует ошибку. Правда, в обоих случаях можно избежать ошибки, но для этого в ссылках необходимо явно указывать сегментный регистр.

2.6.5 Начальная загрузка сегментных регистров

Директива ASSUME сообщает ассмеблеру о том, по каким регистрам он должен сегментировать имена из каких сегментов, и "обещает", что в этих регистрах будут находиться начальные адреса этих сегментов. Однако загрузку этих адресов в регистры сама директива не осуществляет. Сделать такую загрузку - обязанность самой программы, с загрузки сегментных регистров и должно начинаться выполнение программы. Делается это так.

Поскольку в ПК нет команды пересылки непосредственного операнда в сегментный регистр (а имя, т.е. начало, сегмента - это непосредственный операнд), то такую загрузку приходится делать через какой-то другой, несегментный, регистр (например, AX):

MOV AX,DT1 ;AX:=начало сегмента DT1

MOV DS,AX ;DS:=AX

Аналогично загружается и регистр ES.

Загружать регистр CS в начале программы не надо: он, как и счетчик команд IP, загружается операционной системой перед тем, как начинается выполнение программы (иначе нельзя было бы начать ее выполнение). Что же касается регистра SS, используемого для работы со стеком, то он может быть загружен так же, как и регистры DS и ES, однако в MASM предусмотрена возможность загрузки этого регистра еще до выполнения программы (см. 1.7).

2.6.6 Ссылки вперед

Встречая в символьной команде ссылку назад - имя, которое описано

в тексте программы до этой команды, ассемблер уже имеет необходимую информацию об имени и потому может правильно оттранслировать эту команду. Но если в команде встретится ссылка вперед, т.е. имя, которое не было описано до команды и которое, наверное, будет описано позже, то ассемблер в большинстве случаев не сможет правильно оттранслировать эту команду. Например, не зная, в каком программном сегменте будет описано это имя, ассемблер не может определить, по какому сегментному

регистру надо сегментировать имя, и потому не может определить, надо или нет размещать перед соответствующей машинной командой префикс замены сегмента и, если надо, то какой именно.

В подобной ситуации ассемблер действует следующим образом: если в команде встретилась ссылка вперед, то он делает некоторое предположение относительно этого имени и уже на основе этого предположения формирует машинную команду. Если затем (когда встретится описание имени) окажется, что данное предположение было неверным, тогда ассемблер пытается исправить сформированнную им ранее машинную команду. Однако это

не всегда удается: если правильная машинная команда должна занимать больше места, чем машинная команда, построенная на основе предположения (например, перед командой надо на самом деле вставить префикс замены сегмента), тогда ассемблер фиксирует ошибку (как правило, это ошибка номер 6: Phase error between passes.)

Какие же предположения делает ассемблер, встречая ссылку вперед? Во всех командах, кроме команд перехода (о них см. 1.5), ассемблер предполагает, что имя будет описано в сегменте данных и потому сегментируется по регистру DS. Это следует учитывать при составлении программы: если в команде встречается ссылка вперед на имя, которое описа-

но в сегменте, на начало которого указывает сегментный регистр, отлич-

ный от DS, то перед таким именем автор программы должен написать соот-

вествующмй префикс. Пример:

code segment

assume cs:code

x dw ?

beg: mov ax,x ;здесь вместо cs:x можно записать просто x

mov cs:y,ax ;здесь обязательно надо записать cs:y

...

y dw ?

code ends

2.7. Операции ввода-вывода.

Под операциями ввода-вывода понимается ввод данных с клавиатуры и вывод на экран. Для вывода используются готовые фрагменты кода (функции), находящиеся в ОП или системных файлах ОС. Для вызова используется команда INT N - вызова аппаратного или программного прерывания. Полное определение и смысл прерываний будет рассмотрен далее. N - непосредственно указываемый номер прерывания. Рассмотрим некоторые функции отдельных прерываний.

Прерывания BIOS.

Int 10h video services (обслуживание видео)

Регистр АН используется для занесения в него номера выполняемой функции.

00 - (mov ah,0) - установка режима вывода (текстовой, графический)

AL - номер режима (03 - обычный текстовый - 80х25, 13 - графика 640х480 256 цветов)

05h - выбор страницы на которую выводятся данные. AL - номер страницы. Начальная - 00, текстовых - 8, графических -2, для адаптеров VGA.

02h - установка позиции курсора

bh - номер видеостраницы;

dh - номер ряда, начиная с 00;

dl - номер колонки, начиная с 00;

09h - вывод символа в позицию курсора

al - порядковый номер символа в соответствии с ASCII.

bh - номер видеостраницы;

bl - атрибуты символа: цвет, цвет фона, мигание.

cx - количество выводимых символов.

0ah - то же что 09, но без задания атрибутов символа bh - игнорируется.

0ch - вывод графического пикселя

al - номер цвета;

bh - номер видеостраницы;

cx - графическая колонка;

dx - графический ряд.

1300h - вывод строки на экран ах=1300Н

bh - номер видеостраницы;

bl - атрибуты символа;

cx - длина строки;

dh,dl - ряд, колонка начала вывода.

es:bp - адрес первого байта строки.

1301h - вывод строки на экран. После вывода производится изменение позиции курсора на следующую после последнего символа выведенной строки. Регистры - как в 1300Н.

1302h - то же что 1300h, но без учета атрибутов символа.

1303h - то же что 1301h, но без учета атрибутов символа.

ГЛАВА 3

ПЕРЕСЫЛКИ. АРИФМЕТИЧЕСКИЕ КОМАНДЫ

3.1. Обозначения операндов команд

При описании команд необходимо указывать, какие операнды в них допустимы, а какие - нет. Для сокращения, примем следующие условные обозначения.

Местонахождение операнда
	

Обозначение
	

Запись в ЯА

в команде
	

i8, i16, i32
	

конст. выражение

в РОН
	

r8, r16, (r32)
	

имя регистра

в сегментном регистре
	

sr
	

cs,ds,ss,es

в ячейке памяти
	

m8, m16, m32
	

адресное выражение

 

Непосредственные операнды, то есть задаваемые в самой команде обозначим буквой i ( от immediate - непосредственный), указывая за ней, сколько разрядов - 8,16 или 32 - отводится на него по команде. Число может быть меньше, но не больше отведенного числа разрядов.

Регистры обозначаются r - register и указание размера регистра r8 - байтовые регистры(ah,cl) r16 - регистры, размером в слово (ax,si) [r32], sr - отдельно.

Если операнд находится в памяти, то указывается адрес соответствющей ячейки. Обозначается m и указывается размер ячейки. Такие операнды называют адресными выражениями.

3.2. Команды пересылки

3.2.1. Команда MOV

В 8086 есть команды пересылки байта или слова (dw - одной командой нет). Епресылаемая величина берется из команды, регистра или ячейки памяти и записывается в рагистр или ячейку памяти. Таких команд много но в ЯА они записываются одинаково mov op1,op2. Ассемблер сам выбирает нужную машинную команду в зависимости от вида операндов. По команде на место первого операнда пересылается значение второго: op1:=op2. Регистр флагов команда не меняет. Mov bx,777 mov cl,bh. В команде mov допустимы следующие комбинации операндов:

op1
	

op2
	

r8
	

i8,r8,m8
	

пересылка

m8
	

i8,r8
	

байтов

r16
	

i16,r16,sr,m16
	

пересылка

sr (but cs)
	

r16,m16
	

слов

m16
	

i16,r16,sr
	

 

Из таблицы видно, что запрещены пересылки из одной ячейкипамяти в другую, из одного сегментного регистра в другой, непосредственного операнда в сегментный регистр. Таких команд нет. Реализуются в две команды например mov ax,22 mov ds,ax ;ds:=22. Нельзя менять cs! Mov переворачивает числа. N dw 1234h ; n 34h n+1 12h ... mov ax,q ;ah 12h.

Определение размера пересылаемых величин: x db ? y db ? mov bh,0 mov x,0 mov si,0 mov y,0. 0 это 00Н или 0000Н. Если не совпадают - ошибка.

3.3. Команды сложения и вычитания

3.3.1.Команды ADD и SUB

В ПК имеются несколько команд сложения и вычитания. Основные:

сложение ADD op1,op2

вычитание SUB op1,op2 ;subtract

В этих командах допустимы следующие комбинации операндов:

op1
	

op2
	

r8
	

i8,r8,m8
	

сложение/вычитание

m8
	

i8,r8
	

байтов

r16
	

i16,r16,m16
	

сложение/вычитание

m16
	

i16,r16
	

слов

 

Команда ADD складывает операнды и записывает их сумму на место первого операнда op1:=op1+op2. Например add ch,22;sub si,x;add ax, -300. Команды ADD и SUB работают как с числами размером в байт, так и с числами размером в слово. нельзя, чтобы один операнд был размером в байт, другой в слово.

3.3.2. Особенности сложения и вычитания чисел.

Могут возникать ситуации, когда например в ячейке, размером в байт складываются числа 250 и 10, получается число 260 (100000100b), которое не «влезает» в ячейку. В этом случае левая единица отбрасывается и в качестве ответа выдается искаженная сума (в приведенном примере - число 4) но в флаг переноса CF записывается 1. Это признак получения неправильного результата (если переноса не было то в CF заносится 0). Затем можно проанализировать этот флаг и отловит подобную ошибку. Суммирование с отбрасыванием единицы переноса называется суммированием по модулю 2к k - размер ячейки. При этом в cf фиксируется был ли перенос.

x+у, если х+у< 2k , cf=0

Сумма (х,у)=(х+у) mod 2k= x+у-2k, если х+у< 2k , cf=1

Аналогичная проблема возникает при вычитании беззнаковых х-у, если х<y. При этом происходит следующее. Числу x дается заем, единицы, то есть к числу x прибавляется 2k и только после этого производится вычитание. Например при k=8 вычитание 1-3 осуществляется так.

1-3=(28+1)-3=(256+1)-3=257-3=254 то есть замена 0000001b на 1000001b.

x-у, если х>=у , cf=0

Разность (х,у)=(х-у) mod 2k= (2k+x)-y если х<у, cf=1

Таким образом сложение и вычитание беззнаковых чисел производится по модулю 2k, а установленный флаг переноса свидетельствует о неправильности результата.

Знаковые числа складываются и вычитаются по алгоритму беззнаковых чисел. Дополнительные коды знаковых операндов рассматривают как числа без знака и в таком виде складывают или вычитают, а полученный результат рассматривают как дополнительный код знакового ответа. Например. При байтовой ячейке. Надо сложить +3 и -1 их дополнительные коды 3 и (256-1)=255. Складываем их как числа без знака 3+255 (mod 256)=258 (mod 256)=2. Далее величина 2 рассматривается как дополнительный код, то есть +2. Пример. Сложить -3 и +1. Дополнительные коды этих знаковых чисел (256-3)=253 и 1. Складываем их как беззнаковые числа. 253+1 (mod 256) =254. В дополнительном коде результат =-2 (254=256-2). Следовательно для сложения и вычитания беззнаковых и знаковых чисел не нужны разные машинные коды.

Однако при ячейке размером 8 битов в дополнительном коде представляются числа 0т -128 до 127. Рассмотрим сложение чисел +127 и +2. Складывая их как беззнаковые 127 и 2 получаем 129, дополнительный код которой 129=256-127, суммой должно быть признано число -127! Складывая положительные числа получаем отрицательное.

Почему так получилось? В дополнительном коде левый разряд является знаковым. 129=10000001b модуль которого не вмещается в 7 разрядов и «залез» в знаковый разряд, изменив его на противоположный. Такое налезание модуля числа на знаковый разряд называют «переполнением мантиссы». Возникает при сложении и вычитании знаковых чисел, при выходе результата за границы диапазона знаковых чисел. Фиксируется в флаге переполнения OF. При переполнении мантиссы флаг устанавливается. OF=0 - результат правильный, OF =1 - неправильный. Оба флага изменяются и программист отслеживает необходимый.

Меняются также ZF - значение 1,если результат нулевой, иначе флаг сброшен и sf, куда заносится знаковый бит.

В итоге могут меняться флаги CF,OF,SF,ZF а также AF и PF.

3.3.3. Команды INC, DEC и NEG.

INC op ; (increment) увеличение операнда на 1

DEC op ; (decrement) уменьшение операнда на 1

NEG op ; (negative) изменение знака

Здесь допустимы типы операнда: r8, m8, r16, m16. Например: inc ax, inc ch, dec word ptr year. Команда inc аналогична команде add op,1, а команда dec - sub op,1, с той разницей, что эти команды не меняют флаг переноса CF. Занимают меньше места в памяти и выполняются быстрее. Команда neg рассматривает операнд как число со знаком и меняет его на противоположный op:=-op. Например:

mov dl,1

neg dl ; dl:=-1 (0FFh)

Флаги: CF=1; OF=0; ZF, SF - меняются как обычно. Если операнд нулевой, то CF=0. Исключение. При byte ptr оp=-128 (80h) операнд не изменяется, так как нет знакового числа +128 (тоже при word ptr оp=-32768 (8000h)). Здесь OF=1.

3.3.4. Команды ADC и SBB.

ADC op1,op2 ; (add with carry): сложение с учетом переноса.

SBB op1,op2 ; (subtract with carry): вычитание с учетом переноса.

Выполняют действия операторов add и sub, и дополнительно к сумме операндов прибавляется значение флага переноса CF - по команде ADC op1:=op1+op2+CF, и из разности операндов вычитается CF - op1:= op1+op2+CF для sbb. Используется для сложения чисел больших чем слово.

3.4. Команды умножения и деления.

3.4.1. Команды умножения.

MUL op (multiply) умножение целых без знака.

IMUL op (integer multiply) умножение целых со знаком.

Умножение байтов: AX:=AL*op (op:r8,m8)

Умножение слов: (DX,AX):=AX*op (op:r8,m8)

Операнд, указываемый в команде - это один из сомножителей, он может находится в регистре или в памяти, но не может быть непосредственным операндом. Местонахождение другого сомножителя фиксировано и потому не указывается в команде явно: при умножении байтов он берется из регистра AL, а при умножении слов - из AX. Местонахождение результата также известно и в команде явно не указывается. Под результат отводится в два раза больше места чем под сомножитель. При умножении байтов результат имеет размер слова и помещается в регистр AX (AH - старшая часть, AL - младшая), при умножении слов результат имеет размер двойного слова и заносится в два регистра DX - старшие цифры произведения, в AX - младшие. Примеры x db 10 ... mov al,26 mul x ;ax=26*10=104h ah=10h, al=04h mov ax,8 mov bx, -1 imul bx ;(dx,ax)=-8=0FFFFFFF8h dx=0FFFFh ax=0FFFFh;

Флаги CF и OF меняются синхронно:

CF=OF=1 - если произведение имеет двойной формат

CF=OF=0 - если произведению достаточен формат сомножителей.

3.4.2. Умножение на процессорах 80186 и старше

В процессоре 80186 была введена команда умножения с тремя операндами:

MUL op1,op2, op3 или IMUL op1,op2,op3

op1:=op2*op3. Допустимые типы операндов: op1:r16 op2:r16,m16 op3:i16. Например mul si,dx,40. Результат и операнды имеют размер слова, поэтому если флаги CF=OF=0 то результат поместился в регистр-слово, а если CF=OF=1, то старшая часть утеряна и результат неверен. Если первый сомножитель берется из регистра в который должен быть записан результат, то в команде этот регистр может быть указан однажды. MUL op1,op3 (IMUL op1,op3) mul dx,35.

По умолчанию ассемблер воспринимает только команды 8086 процессора. Чтобы ассемблер правильно воспринимал команды 80186 процессора необходимо в любом месте программы (но до первой такой команды) указать директиву .186 (для 80286 -.286, для 80386 - .386, для 80486 - .486).

3.4.3. Команды деления

Деление чисел без знака и со знаком реализуется командами

DIV op (divide) деление целых без знака

IDIV op (integer divide) деление целых со знаком

деление слова на байт:

AH:= AX mod op, AL:=AX div op (op:r8,m8)

деление слова на слово:

DX:=(DX,AX) mod op, AX:=(DX,AX) div op (op:r16,m16)

В командах местонахождение первого операнда (делимого) фиксировано и явно не указывается. Под делением понимают получение двух величин - неполного частного (div) и остатка (mod). Оба числа помещаются на место делимого - старшая часть заменяется на остаток, младшая - на неполное частное. Имеют размер, совпадающий с делителем.

Если trunc - отбрасывание дробной части, то

a div b = trunc(a/b)

a mod b = a-b*(a div b)

13 div 4 = 3 13 mod 4 = 1

При выполнении команды деления возможно появление ошибки «деление на 0 или переполнение» в случаях:

делитель равен 0 (op=0)

неполное частное не вмещается в отведенное ему место (600/2).

При такой ошибке ПК прекращает выполнение программы.

3.6.4. Изменение размера числа

Пусть к числу из регистра ВХ нужно прибавить число из AL. Но команды сложения слова с байтом в ПК нет. Размеры этих чисел необходимо сделать равными, расширить байт до слова, записав его, например в АХ.

Если число трактуется как беззнаковое, то надо слева приписать нули, присвоив AH:=00. Для чисел со знаком необходимо приписывать 0FFh.

Команда расширения:

CBW (convert byte to word) расширение байта до слова.

Операнд всегда берется из AL, а результат всегда записывается в АХ, то есть

. Флаги команда не меняет.

ГЛАВА 4

КОМАНДЫ ПЕРЕХОДА. ОРГАНИЗАЦИЯ ЦИКЛОВ

4.1. Безусловный переход. Оператор SHORT

4.1.1 Определение

Для нарушения порядка в котором следуют команды машинной программы применяются команды перехода. Если переход делается, когда выполнено некоторое условие, то такой переход называется условным, а если он делается независимо от условий, то это безусловный переход.

Команды перехода не меняются флаги.

JMP ор (jump) безусловный переход

Здесь операнд тем или иным способом указывает адрес перехода, т. е. адрес команды, которая должна быть выполнена следующей. Рассмотрим, эти за способы.

4.1.2. Прямой переход

В данном случае в качестве ор указывается метка той команды, на которую надо передать управление:

JMP <метка>

Пример: JMP L1 L1: MOV АХ,0

Ассемблер вычисляет разницу между адресом команды перехода и адресом команды выполняется переход подставляет разницу в код.

4.2.3. Оператор SHORT.

Jmp L1 ; длинный переход - команда занимает 3 байта и дальность перехода от -215 до 215-1 байт.

Jmp short L1 ; короткий переход - команда занимает 2 байта и дальность перехода от -128 до 127 байт.

4.1.3.Косвенный переход.

В команде указывается не адрес перехода, а место где он находится:

JMP r16 или JMP m16

Здесь содержимое регистра или ячейки памяти является адресом команды на которую осуществляется переход. Модифицируется регистр IP.

4.2. Команды сравнения и условного перехода

4.2.1. Команда сравнения

Командам условного перехода как правило предшествует команда сравнения двух величин, результатом которого является изменение флагов.

CMP op1,op2 ;(compare) сравнение.

Флаги изменяются как по команде вычитания:

CF и AF становятся флагами заема и устанавливаются в 1 когда op2>op1. ZF устанавливается если результат вычитания op1-op2 нулевой, SF устанавливается если результат отрицательный.

4.2.2. Команды условного перехода

Jxx op

операнд указывает метку на которую следует сделать переход.

Для всех чисел справедливы следующие команды

JE (equal) op1=op2 ZF=1

JNE (not) op1¹op2 ZF=0

Для чисел со знаком

(здесь принимаются следующие обозначения: G -greater, L - less):

JL(JNGE) op1<op2 SF¹OF

JLE(JNG) op1£op2 SF¹OF или ZF=1

JG(JNLE) op1>op2 SF=OF и ZF=1

JGE(JNL) op1³op2 SF=OF

Для чисел без знака

(здесь принимаются следующие обозначения: A - above, B - below):

JB(JNAE) op1<op2 CF=1

JBE(JNA) op1£op2 CF=1 или ZF=1

JA(JNBE) op1>op2 CF=0 и ZF=0

JAE(JNB) op1³op2 CF=0

Переходы по флагам

JZ ZF=1 JNZ ZF¹1

JS SF=1 JNS SF¹1

JC CF=1 JNC CF¹1

JO OF=1 JNO OF¹1

JP PF=1 JNP PF¹1

Переход по значению регистра CX

JCXZ <метка> jump if CX is zero.

4.3. Команды организации циклов.


Команда LOOP.

Некоторую последовательность команд необходимо повторить N раз:

mov cx,N

label1: ...

dec cx

cmp cx,0

jne label1
	

LOOP <метка>

mov cx,N

label1: ...

loop label1

 

Справедливо для N>0, чтобы при сх=0 обойти цикл:

mov cx,N

jcxz la1

la: ...

loop la

la1: ...

Команда реализует короткий переход

Также существуют команды LOOPE (loopz) и LOOPNE (loopnz).

ГЛАВА 5.

ЛОГИЧЕСКИЕ КОМАНДЫ

5.1. Команды сдвига

5.1.1. Циклический сдвиг

ROL Циклический сдвиг влево всех бит операнда.
Химия: решение задач

Rol op,1 сдвиг на 1 бит. Старший бит операнда загружается на место младшего. Rol op,cl сдвиг на число бит, указанное в регистре cl. (mov dl,8 rol dl,1 ;dl=10h)Для всех сдвигов допустимые типы операндов r8,m8,r16,m16.

ROR Циклический сдвиг вправо всех бит операнда.

ror op,1 сдвиг на 1 бит. Младший бит операнда загружается на место старшего. Rol op,cl сдвиг на число бит, указанное в регистре cl. (mov dl,8 ror dl,1 ; dl=4) Фактически реализует беззнаковое умножение (деление) на степень числа 2.

5.1.2. Циклический сдвиг через бит переноса.

RCL циклический сдвиг влево через бит переноса. Rcl op,1 сдвиг на 1 бит. В младший бит операнда заносится значение флага CF, старший бит – в CF, rcl op,cl - cl раз.

RCL циклический сдвиг вправо через бит переноса. Rcr op,1 сдвиг на 1 бит. В старший бит операнда заносится значение флага CF, младший бит – в CF, rcr op,cl - cl раз.

5.1.3. Логический и арифметический сдвиг.

SHR логический сдвиг вправо. В старший бит операнда заносится 0, а старший теряется.

SAL/SHL арифметический сдвиг влево/логический сдвиг влево.

sal op,1 старший бит поступает в CF в младший бит загружается 0. Эквивалентно умножению знакового числа на 2. Sal op,cl – умножение на степень числа 2. (mov al,7 mov si,-1 ;si=0ffffh mov cl,4 sal al,1 ;al=0eh=7*2 sal si,cl ;si=0FFF0h=-1*16=-16)

SAR op,1 арифметический сдвиг вправо всех бит операнда. Младший бит поступает в CF. Старший бит сохраняет значение.

5.1.4. Команда XLAT

Содержимое байта памяти, адрес которого равен сумме значений регистров ВХ и, записывается в AL. Флаги не меняются.

Hexs db ‘0123456789ABCDEF’

Lea bx,dig16

Xlat

5.2 Битовые операции.

5.2.1. Логические команды.

NOT op отрицание.

Меняет значение каждого бита операнда на противоположный. Результат заносится на место операнда. Допустимые типы операнда r8,m8,r16,m16.

x
	

y
	

Not x
	

x and y
	

x or y
	

X xor y

1
	

1
	

0
	

1
	

1
	

0

1
	

0
	

0
	

0
	

1
	

1

0
	

1
	

1
	

0
	

1
	

1

0
	

0
	

1
	

0
	

0
	

0

 

AND op1,op2 конъюнкция (логическое умножение)

Производит поразрядное (побитное) логическое умножение операндов и заносит на место op1.i- й бит результата =1 только если i-е биты обоих операндов =1 и =0 если хотя бы один бит =0.

Op1 op2

R8 i8,r8,m8

M8 i8,r8

R16 i16,r16,m16

M16 i16,r16

TEST op1,op2 то же что and но без занесения результата. Zf=0, если результат =0

OR op1,op2 дизъюнкция (логическое сложение) Производит поразрядное (побитное) логическое сложение операндов и

XOR op1,op2 Исключающее или. Заносит результат на место op1. i- й бит результата =0 если i-е биты операндов совпадают и =0 если они различны.